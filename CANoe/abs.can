/*@!Encoding:949*/
includes {
  
}

variables {
  //send message
  message ABS_Info_Cluster abs_msg;
  message ABS_Alive abs_alive_msg;
  message CCAN::ABS_Pos_Respond_OTA abs_pos_msg;
  message CCAN::ABS_Neg_Respond_OTA abs_neg_msg;
  //timer
  msTimer t_abs;

  //var
  int brake_pressed = 0;
  int cur_speed = 0;
  int prev_speed = 0;

  float decel = 0.0;
  int abs_active = 0;
  int abs_prev = 0;
  
  float v1;
  float v2;
  float tmp1;
  float tmp2;
  
  int my_ecu_name = 5;
  int rxbuffer[20000];
  int rxoffset = 0;
  int metadata_recved = 0;

  // metadata
  int version = 0;
  int file_size = 0;
}

on start {
  //setTimerCyclic(t_abs, 5); // 5ms 주기 ABS 판단 시작
}

// 속도 수신 (km/h)
on message Motor_Info_ECU {
  cur_speed = this.sig_car_speed;
}

// 브레이크 입력 수신 (flag: 0 or 1)
on message Brake_Control_ECU {
  brake_pressed = this.sig_brake_pressed;
}

// ABS 판단 로직 (5ms 주기)
on timer t_abs {
  tmp1 = prev_speed;
  tmp2 = cur_speed;

  v1 = tmp1 / 3.6;
  v2 = tmp2 / 3.6;
  decel = (v1 - v2) / 0.005;            // m/s²

  // ABS ON 조건 
  if (brake_pressed && decel > 20.0 && cur_speed > 10) {
    abs_active = 1;
  }
  // OFF 조건
  else if (abs_active && (decel < 10.0 || !brake_pressed || cur_speed < 5)) {
    abs_active = 0;
  }

  // 상태 변화 시 메시지 전송
  if (abs_active != abs_prev) {
    abs_msg.sig_abs_active = abs_active;  // 0 or 1
    output(abs_msg);
    abs_prev = abs_active;
  }

  // 다음 주기 준비
  prev_speed = cur_speed;
  
  output(abs_alive_msg);
}

on message CCAN::VUM_Request_ECU
{
  if(this.sig_sid ==0x12)
  {
    abs_pos_msg.sig_sid = this.sig_sid+0x40;
    output(abs_pos_msg);
  }
  
  if(this.sig_sid ==0x15)
  {
    if(metadata_recved ==1)
    {
      if (rxoffset == file_size)
      {
        abs_pos_msg.sig_sid = this.sig_sid+0x40;
      }
      else
      {
        abs_neg_msg.sig_neg_respond = 0x7F;
        abs_neg_msg.sig_sid = this.sig_sid;
      }
      output(abs_pos_msg);
    }
  }
  
  //negative
}

on message CCAN::VUM_Metadata_ECU
{
  if(this.sig_ecu_name == my_ecu_name)
  {
    file_size = this.sig_file_size;
    version = this.sig_version;
    abs_pos_msg.sig_sid = this.sig_sid + 0x40;
    output(abs_pos_msg);
    metadata_recved = 1;
  }
  write("metadata comes in!");
}

on message C_CAN::VUM_File_ABS
{
  int count = 0;
  int len = 0;

  if (file_size - rxoffset >= 8) {
    len = 8;
  }
  else {
    len = file_size - rxoffset;
  }
  for (count = 0;count < len;count++)
  {
    rxbuffer[rxoffset] = this.byte(count);
    rxoffset++;
  }

  if ((rxoffset % 4000 == 0) || rxoffset == file_size) {
    abs_pos_msg.sig_sid = 0x14 + 0x40;
    output(abs_pos_msg);
  }
  
  @sysvar::VUM::update_progress = (int)(((double)rxoffset / (double)file_size) * 100);

  write("payload comes in!, %d", rxoffset);
}