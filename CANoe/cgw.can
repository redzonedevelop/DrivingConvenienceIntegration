/*@!Encoding:949*/
includes
{
  
}




variables
{
  UdpSocket gSocket;
  char      gRxBuffer[1500];
  char      gTxBuffer[1500];
  char      gGetSysBuffer[1500];
  msTimer send_loop;
  
  int fullLength = 0;
  int chunkSize = 252;
  int offset = 0;

  
  
  //var
  
  
  //P-CAN
  message PCAN::Brake_Control_Motor brake_control_p_msg;
  message PCAN::ADAS_Control_Motor motor_control_p_msg;
  message PCAN::VUM_Request_ECU vum_request_p_msg;
  
  //C-CAN
  message CCAN::Motor_Info_ECU motor_info_c_msg;
  message CCAN::ADAS_Control_Steering steering_control_c_msg;
  message CCAN::VUM_Request_ECU vum_request_c_msg;
  message CCAN::ABS_Request_OBD abs_obd_msg;
  //B-CAN
  message BODY::Steering_Angle_Info_ECU steering_info_b_msg;
  message BODY::VUM_Request_ECU vum_request_b_msg;
  //ADAS-CAN
  message ADASCAN::VUM_Request_ECU vum_request_adas_msg;
  //OTA-CAN not exist sorry
  
  //OC-CAN
  message OCCAN::ABS_Info_Cluster abs_info_oc_msg;
  message OCCAN::ADAS_Info_Cluster adas_info_oc_msg;
  message OCCAN::AEB_Info_ECU aeb_info_oc_msg;
  message OCCAN::Battery_Info_Cluster battery_info_oc_msg;
  message OCCAN::Light_Info_Cluster light_info_oc_msg;
  message OCCAN::Motor_Info_ECU motor_info_oc_msg;
  message OCCAN::Steering_Angle_Info_ECU steering_angle_oc_msg;
  message OCCAN::Transmission_Info_ECU transmission_info_oc_msg;
  message OCCAN::VUM_Request_ECU vum_request_oc_msg;
  message OCCAN::ECU_Request_OBD ecu_obd_msg;
  
  // request & respond
  const int DTC = 0x10;
  const int RXSWIN = 0x11;
  const int UPDATE_MODE = 0x12;
  const int METADATA = 0x13;
  const int PAYLOAD = 0x14;
  const int VERIFY = 0x15;
  const int ROLLBACK = 0x16;
  const int OTA_ERROR = 0x7F;
  
  // ECU NUM
  const int Motor = 0;
  const int Transmission = 1;
  const int BMS = 2;
  const int ECU_ABS = 5;
  const int Brake = 4;
  const int Steering = 6;
  const int ADAS = 8;
  const int VUM = 20;
  const int Illuminate = 13;
  const int Rain = 12;
  const int Light = 14;
  const int Seat = 15;
  const int OBD = 16;
  const int Cluster = 17;
}

on start
{
  // Open an UDP socket. As source address 0.0.0.0 is used, this means that
  // the configure address of the TCP/IP stack is used. See TCP/IP stack
  // configuration dialog in the simulation setup
  // As port no ist used, this means a source port is dynamically assign
  // by the TCP/IP stack.
  
  gSocket = UdpSocket::Open( IP_Endpoint(0.0.0.0:40001) );
   
  if (IpGetLastError() != 0)
  {
    // if UdpSocket::Open fails, we print a message to the write window
    write( "<%BASE_FILE_NAME%> UdpSocket::Open failed with result %d", IpGetLastError() );
  }
    
  // To receive data with the created socket, we have to call ReceiveFrom.
  gSocket.ReceiveFrom( gRxBuffer, elcount(gRxBuffer) );
    
  // if ReceiveFrom does not immediatelly copy to to gRxBuffer, it returns 997 to
  // indicate it will call the callback function OnUdpReceiveFrom later.
  if ((gSocket.GetLastSocketError() != 0) && (gSocket.GetLastSocketError()  != 997))
  {
    char errorString[100];
    // if ReceiveFrom fails, we print a message to the write window
    gSocket.GetLastSocketErrorAsString( errorString, elcount(errorString) );
    write( "<%BASE_FILE_NAME%> ReceiveFrom failed with result %d (%s)", IpGetLastError(), errorString );
  }
}




//P-CAN
on message PCAN::Battery_Info_Cluster
{
  battery_info_oc_msg.sig_battery_level   = this.sig_battery_level;
  battery_info_oc_msg.sig_charging_state  = this.sig_charging_state;
  output(battery_info_oc_msg);
}



on message PCAN::BMS_Neg_Respond_OTA
{
  
}

on message PCAN::BMS_Pos_Respond_OTA
{
  if(this.sig_sid == (UPDATE_MODE + 0x40)){ 
    update_mode_respond(this.sig_sid ,BMS);
  }
  else if(this.sig_sid == (METADATA + 0x40)){
    metadata_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (VERIFY + 0x40)){
    verification_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (ROLLBACK + 0x40)){
    //to-do: rollback respond
  }
}

on message PCAN::BMS_Request_OBD
{
  
}

on message PCAN::Motor_Info_ECU
{
  motor_info_c_msg.sig_car_speed       = this.sig_car_speed;
  motor_info_c_msg.sig_wheel_speed_FL  = this.sig_wheel_speed_FL;
  motor_info_c_msg.sig_wheel_speed_FR  = this.sig_wheel_speed_FR;
  motor_info_c_msg.sig_wheel_speed_RL  = this.sig_wheel_speed_RL;
  motor_info_c_msg.sig_wheel_speed_RR  = this.sig_wheel_speed_RR;
  
  motor_info_oc_msg.sig_car_speed       = this.sig_car_speed;
  motor_info_oc_msg.sig_wheel_speed_FL  = this.sig_wheel_speed_FL;
  motor_info_oc_msg.sig_wheel_speed_FR  = this.sig_wheel_speed_FR;
  motor_info_oc_msg.sig_wheel_speed_RL  = this.sig_wheel_speed_RL;
  motor_info_oc_msg.sig_wheel_speed_RR  = this.sig_wheel_speed_RR;

  output(motor_info_c_msg);
  output(motor_info_oc_msg);
}

on message PCAN::Motor_Neg_Respond_OTA
{
  
}

on message PCAN::Motor_Pos_Respond_OTA
{
  if(this.sig_sid == (UPDATE_MODE + 0x40)){ 
    update_mode_respond(this.sig_sid ,Motor);
  }
  else if(this.sig_sid == (METADATA + 0x40)){
    metadata_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (VERIFY + 0x40)){
    verification_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (ROLLBACK + 0x40)){
    //to-do: rollback respond
  }
}

on message PCAN::Motor_Request_OBD
{
  
}

on message PCAN::Transmission_Info_ECU
{
  transmission_info_oc_msg.sig_gear_mode = this.sig_gear_mode;
  
  output(transmission_info_oc_msg);
}

on message Transmission_Neg_Respond_OTA
{
  
}

on message Transmission_Pos_Respond_OTA
{
  if(this.sig_sid == (UPDATE_MODE + 0x40)){ 
    update_mode_respond(this.sig_sid ,Transmission);
  }
  else if(this.sig_sid == (METADATA + 0x40)){
    metadata_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (VERIFY + 0x40)){
    verification_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (ROLLBACK + 0x40)){
    //to-do: rollback respond
  }
}

on message Transmission_Request_OBD
{
  
}


//C-CAN
on message CCAN::ABS_Alive
{

}

on message CCAN::ABS_Info_Cluster
{
  abs_info_oc_msg.sig_abs_active = this.sig_abs_active;
  output(abs_info_oc_msg);
}

on message CCAN::ABS_Neg_Respond_OTA
{

}

on message CCAN::ABS_Pos_Respond_OTA
{
  if(this.sig_sid == (UPDATE_MODE + 0x40)){ 
    update_mode_respond(this.sig_sid ,ECU_ABS);
  }
  else if(this.sig_sid == (METADATA + 0x40)){
    metadata_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (VERIFY + 0x40)){
    verification_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (ROLLBACK + 0x40)){
    //to-do: rollback respond
  }
}

on message CCAN::ABS_Request_OBD
{
  ecu_obd_msg.sig_sid = this.sig_sid;
  output(ecu_obd_msg);
}

on message CCAN::ABS_Slave_Active
{
 
}

on message CCAN::AEB_Info_ECU
{

}

on message CCAN::Brake_Control_ECU
{
  brake_control_p_msg.sig_brake_pressed =  this.sig_brake_pressed;
  brake_control_p_msg.sig_brake_level = this.sig_brake_level;
  
  output(brake_control_p_msg);
}

on message CCAN::Brake_Neg_Respond_OTA
{

}

on message CCAN::Brake_Pos_Respond_OTA
{
  if(this.sig_sid == (UPDATE_MODE + 0x40)){ 
    update_mode_respond(this.sig_sid ,Brake);
  }
  else if(this.sig_sid == (METADATA + 0x40)){
    metadata_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (VERIFY + 0x40)){
    verification_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (ROLLBACK + 0x40)){
    //to-do: rollback respond
  }
}

on message CCAN::Brake_Request_OBD
{

}

on message CCAN::Steering_Angle_Info_ECU
{
  steering_info_b_msg.sig_steering_angle = this.sig_steering_angle;
  output(steering_info_b_msg);
}

on message CCAN::Steering_Neg_Respond_OTA
{

}

on message CCAN::Steering_Pos_Respond_OTA
{
  if(this.sig_sid == (UPDATE_MODE + 0x40)){ 
    update_mode_respond(this.sig_sid ,Steering);
  }
  else if(this.sig_sid == (METADATA + 0x40)){
    metadata_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (VERIFY + 0x40)){
    verification_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (ROLLBACK + 0x40)){
    //to-do: rollback respond
  }
}

on message CCAN:: Steering_Request_OBD
{

}



//B-CAN
on message BODY::Illuminate_Info_Cluster
{

}

on message BODY::Illuminate_Neg_Respond_OTA
{

}

on message BODY::Illuminate_Pos_Respond_OTA
{
  if(this.sig_sid == (UPDATE_MODE + 0x40)){ 
    update_mode_respond(this.sig_sid ,Illuminate);
  }
  else if(this.sig_sid == (METADATA + 0x40)){
    metadata_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (VERIFY + 0x40)){
    verification_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (ROLLBACK + 0x40)){
    //to-do: rollback respond
  }
}

on message BODY::Illuminate_Request_OBD
{

}

on message BODY::Light_Info_Cluster
{
  light_info_oc_msg.sig_fog_light  = this.sig_fog_light;
  light_info_oc_msg.sig_high_beam  = this.sig_high_beam;
  light_info_oc_msg.sig_low_beam   = this.sig_low_beam;
  light_info_oc_msg.sig_drive_mode = this.sig_drive_mode;
  light_info_oc_msg.sig_rain_road = this.sig_rain_road;
  
  output(light_info_oc_msg);
}

on message BODY::Light_Neg_Respond_OTA
{

}

on message BODY::Light_Pos_Respond_OTA
{
  if(this.sig_sid == (UPDATE_MODE + 0x40)){ 
    update_mode_respond(this.sig_sid ,Light);
  }
  else if(this.sig_sid == (METADATA + 0x40)){
    metadata_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (VERIFY + 0x40)){
    verification_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (ROLLBACK + 0x40)){
    //to-do: rollback respond
  }
}

on message BODY::Light_Request_OBD
{

}

on message BODY::Rain_Neg_Repond_OTA
{

}

on message BODY::Rain_Pos_Respond_OTA
{
  if(this.sig_sid == (UPDATE_MODE + 0x40)){ 
    update_mode_respond(this.sig_sid ,Rain);
  }
  else if(this.sig_sid == (METADATA + 0x40)){
    metadata_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (VERIFY + 0x40)){
    verification_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (ROLLBACK + 0x40)){
    //to-do: rollback respond
  }
}

on message BODY::Rain_Request_OBD
{

}

on message BODY::Seat_Neg_Respond_OTA
{

}

on message BODY::Seat_Pos_Respond_OTA
{
  if(this.sig_sid == (UPDATE_MODE + 0x40)){ 
    update_mode_respond(this.sig_sid ,Seat);
  }
  else if(this.sig_sid == (METADATA + 0x40)){
    metadata_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (VERIFY + 0x40)){
    verification_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (ROLLBACK + 0x40)){
    //to-do: rollback respond
  }
}

on message BODY::Seat_Request_OBD
{

}

on message BODY::Steering_Angle_Info_ECU
{
  steering_angle_oc_msg.sig_steering_angle = this.sig_steering_angle;
  
  output(steering_angle_oc_msg);
}


//ADAS-CAN
on message ADASCAN::ADAS_Control_Brake
{
  aeb_info_oc_msg.sig_aeb_active = this.sig_control_aeb;
  
  output(aeb_info_oc_msg);
}

on message ADASCAN::ADAS_Control_Motor
{
  motor_control_p_msg.sig_control_speed = this.sig_control_accerleration;//ï¿½×³ï¿½ longitudinal speedï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿?
  //motor_control_p_msg.sig_control_speed = @sysvar::Motor::longitudinal_speed;
  write("cgw speed %d\n",this.sig_control_accerleration);
  output(motor_control_p_msg);
}

on message ADASCAN::ADAS_Control_Steering
{
  steering_control_c_msg.sig_control_steering = this.sig_control_steering; // todoï¿½ï¿½Æ¼ï¿½î¸µï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½Ø¼ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ØµÖ¾ï¿½ï¿½ï¿?
  output(steering_control_c_msg);
}

on message ADASCAN::ADAS_Info_Cluster
{
  adas_info_oc_msg.sig_ACC = this.sig_ACC;
  adas_info_oc_msg.sig_AEB = this.sig_AEB;
  adas_info_oc_msg.sig_LKA = this.sig_LKA;
  output(adas_info_oc_msg);
}

on message ADASCAN::ADAS_Neg_Respond_OTA
{
  
}

on message ADASCAN::ADAS_Pos_Respond_OTA
{
  if(this.sig_sid == (UPDATE_MODE + 0x40)){ 
    update_mode_respond(this.sig_sid ,ADAS);
  }
  else if(this.sig_sid == (METADATA + 0x40)){
    metadata_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (VERIFY + 0x40)){
    verification_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (ROLLBACK + 0x40)){
    //to-do: rollback respond
  }
}

on message ADASCAN::ADAS_Request_OBD
{
  
}


//OC-CAN
on message OCCAN::Cluster_Neg_Respond_OTA
{
  
}

on message OCCAN::Cluster_Pos_Respond_OTA
{
  if(this.sig_sid == (UPDATE_MODE + 0x40)){ 
    update_mode_respond(this.sig_sid ,Cluster);
  }
  else if(this.sig_sid == (METADATA + 0x40)){
    metadata_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (VERIFY + 0x40)){
    verification_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (ROLLBACK + 0x40)){
    //to-do: rollback respond
  }
}

on message OCCAN::Cluster_Request_OBD
{
  
}

on message OCCAN::OBD_MIL_Cluster
{
  
}

on message OCCAN::OBD_Neg_Respond_OBD
{
  
}


on message OCCAN::OBD_Neg_Respond_OTA
{
  
}

on message OCCAN::OBD_Pos_Respond_OBD
{
  
}

on message OCCAN::OBD_Pos_Respond_OTA
{
  if(this.sig_sid == (UPDATE_MODE + 0x40)){ 
    update_mode_respond(this.sig_sid ,OBD);
  }
  else if(this.sig_sid == (METADATA + 0x40)){
    metadata_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (VERIFY + 0x40)){
    verification_receive_respond(this.sig_sid);
  }
  else if(this.sig_sid == (ROLLBACK + 0x40)){
    //to-do: rollback respond
  }
}

//OTA-CAN

dword calcCRC32(byte data[], int len)
{
  int i, j;
  dword temp, crc, mask;
  
  i = 0;
  crc = 0xFFFFFFFF;
  while(i < len){
    temp = (dword)data[i];
    crc = crc ^ temp;
    for (j = 7; j >= 0; j--){
      mask = -(crc & 1);
      crc = (crc >> 1) ^ (0xEDB88320 & mask);
    }
    i = i + 1;
  }
  return ~crc;
}

on timer send_loop
{
  byte chunk[256];
  int len;
  int i;
  dword crc;
  
  if (fullLength - offset >= chunkSize){
    len = chunkSize;
  }
  else{
    len = fullLength - offset;
  }
  
  if (offset >= fullLength){
    for (i = 0; i < elcount(gTxBuffer); i++) {
      gTxBuffer[i] = 0;
    } 
    return;  
  }
    
  for(i = 0; i < len; i++){
    chunk[i] = gTxBuffer[offset + i];
  }
  
  crc = calcCRC32(chunk, len);
  
  chunk[len]     = (crc >> 24) & 0xFF;
  chunk[len + 1] = (crc >> 16) & 0xFF;
  chunk[len + 2] = (crc >> 8) & 0xFF;
  chunk[len + 3] = crc & 0xFF;

    
    // send text to IP address/UDP port of the receiver
  gSocket.SendTo( IP_Endpoint(192.168.1.2:40001), chunk, len + 4 );
  
  write("CRC32 calculated: 0x%08X", crc);
  
  offset += len;
  setTimer(send_loop, 100);
}

void update_mode_respond(byte sid, int ECU_NUM){
  byte buf[10];
  dword crc;
  
  buf[0] = sid;
  buf[1] = ECU_NUM;
  
  crc = calcCRC32(buf, 2);
  
  buf[2] = (crc >> 24) & 0xFF;
  buf[3] = (crc >> 16) & 0xFF;
  buf[4] = (crc >> 8) & 0xFF;
  buf[5] = crc & 0xFF;
  
  memcpy_off(gTxBuffer, 0, buf, 0, 6); 

  gSocket.SendTo( IP_Endpoint(192.168.1.3:40001), gTxBuffer, 6 );
}

void metadata_receive_respond(byte sid){
  byte buf[10];
  dword crc;
  
  buf[0] = sid;
  
  crc = calcCRC32(buf, 1);
  
  buf[1] = (crc >> 24) & 0xFF;
  buf[2] = (crc >> 16) & 0xFF;
  buf[3] = (crc >> 8) & 0xFF;
  buf[4] = crc & 0xFF;
  
  memcpy_off(gTxBuffer, 0, buf, 0, 5); 

  gSocket.SendTo( IP_Endpoint(192.168.1.3:40001), gTxBuffer, 5 );
}

void payload_receive_respond(byte sid){
  byte chunk[10];
  dword crc;
  
  chunk[0] = sid;
  
  crc = calcCRC32(chunk, 1);
  
  chunk[1] = (crc >> 24) & 0xFF;
  chunk[2] = (crc >> 16) & 0xFF;
  chunk[3] = (crc >> 8) & 0xFF;
  chunk[4] = crc & 0xFF;
  
  gSocket.SendTo( IP_Endpoint(192.168.1.3:40001), chunk, 5 );
}

void verification_receive_respond(byte sid){
  byte chunk[5];
  dword crc;
  
  chunk[0] = sid;
  
  crc = calcCRC32(chunk, 1);
  
  chunk[1] = (crc >> 24) & 0xFF;
  chunk[2] = (crc >> 16) & 0xFF;
  chunk[3] = (crc >> 8) & 0xFF;
  chunk[4] = crc & 0xFF;
  
  gSocket.SendTo( IP_Endpoint(192.168.1.3:40001), chunk, 5 );
}

on preStop
{
  // Close socket on measurement stop
  gSocket.Close();
}

// Callback function, which is called if a UDP packet is received
void OnUdpReceiveFrom( dword socket, long result, ip_Endpoint remoteEndpoint, byte buffer[], dword size)
{
  int dataLen;
  dword receivedCRC;
  dword calculatedCRC;
  
  if (result == 0)
  {
    char endpointString[30];
    
    remoteEndpoint.PrintEndpointToString( endpointString );

    if (size > 4)
    {
      dataLen = size - 4;
      receivedCRC = ((dword)(buffer[dataLen]     & 0XFF) << 24) | 
                    ((dword)(buffer[dataLen + 1] & 0xFF) << 16) | 
                    ((dword)(buffer[dataLen + 2] & 0XFF) << 8)  | 
                    ((dword)(buffer[dataLen + 3])& 0XFF);
      calculatedCRC = calcCRC32(buffer, dataLen);

      write("Recived CRC32 = 0x%08X, Calculated CRC32 = 0x%08X", receivedCRC, calculatedCRC);

      if (receivedCRC == calculatedCRC) {
        write("CRC correct");
      } else {
        write("CRC miss");
      }
      //sysSetVariableString( sysvar::Receiver::cgw_RxAddress, endpointString );
      // sysSetVariableString( sysvar::Receiver::cgw_RxText, buffer );
    }
    else
    {
      //sysSetVariableString( sysvar::Receiver::cgw_RxAddress, endpointString );
      // sysSetVariableString( sysvar::Receiver::cgw_RxText, "data too short" );
    }
  
  }
  
  if(buffer[0] == UPDATE_MODE){
    
    //todo ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ® ï¿½ï¿½å¸?ï¿½ï¿½ï¿?ecuï¿½ï¿½ ï¿½Ñ·ï¿½ï¿½Ö°ï¿½ ecuï¿½ï¿½ pos ï¿½Ç´ï¿½ neg respond_OTAï¿½Þ½ï¿½ï¿½ï¿½ï¿½ï¿½ vumï¿½ï¿½ï¿½ï¿½ ï¿½Ù½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ö±ï¿½
    vum_request_adas_msg.sig_sid = 0x12;
    output(vum_request_adas_msg);
    vum_request_b_msg.sig_sid = 0x12;
    output(vum_request_b_msg);
    vum_request_c_msg.sig_sid = 0x12;
    output(vum_request_c_msg);
    vum_request_oc_msg.sig_sid = 0x12;
    output(vum_request_oc_msg);
    vum_request_p_msg.sig_sid = 0x12;
    output(vum_request_p_msg);
  }
  else if(buffer[0] == METADATA){
    // 
  }
  else if(buffer[0] == PAYLOAD){
    // 8byteï¿½ï¿½ ï¿½ß¶ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½Ö±ï¿½
  }
  else if(buffer[0] == VERIFY){
    verification_receive_respond(VERIFY + 0x40);
  }
  else if(buffer[0] == ROLLBACK){
    // to-do
  }
  else if(buffer[0] == 0x13){
    
    //metadata_receive_respond();
  }

  // To receive more data, we have to call ReceiveFrom again.
  gSocket.ReceiveFrom( gRxBuffer, elcount(gRxBuffer) );
}

