classdef HelperMotionPrediction <matlab.System
    %HelperMotionPrediction System Object computes future states
    %of the MIOS based on current states using constant velocity model.
    %
    % HelperMotionPrediction System Object uses the current MIO
    % Position to predict the future trajectories of MIO by assuming them
    % to be moving with a constant velocity during the planning time and
    % computing the states accordingly
    %
    % Step function Syntax:function FutureTrajectory = stepImpl(obj,Params,
    % LaneInfo, MIOs). It returns the predicted trajectories of the MIOs,
    % FutureTrajectory respectively based on the information of the planner
    % parameters, Params, global plan points coming from, LaneInfo, and
    % MIOs Frenet state information, MIOs.
    %
    % NOTE: The name of this System Object and it's functionality may
    % change without notice in a future release, or the System Object
    % itself may be removed.
    %
    
    % Copyright 2020-2022 The MathWorks, Inc.
    
    %----------------------------------------------------------------------
    %Private Variables
    properties(Access = private)
        
        %RefPathFrenet holds the object of  referencePathFrenet for a
        %particular Reference Path.
        % RefPathFrenet holds the instance of referencePathFrenet. The
        % RefPathFrenet object is used for transforming the Frenet
        % trajectories to global trajectories.
        RefPathFrenet;
                
        %RefPathPoints is used to store the waypoints for the
        %reference path generated by RefPathFrenet.
        RefPathPoints;

        %PredictedTrajectoryInitStruct defines the predicted trajectory
        % structure that was defined by the Bus object in base workspace.
        % Default = struct
        PredictedTrajectoryInitStruct = HelperLCPlannerDefaultData.PredictedTrajectories;

        % Time Horizon for which the planning has to be done.
        % Default value = 3
        TimeHorizons = 3;
        
        % TimeResolution defines the time interval between.
        % Default = 0.1
        TimeResolution = 0.1;
        
        % Total Number of Target vehicles.
        % Default = 50
        NumTargets = 50;
    end
    
    %----------------------------------------------------------------------
    % Main algorithm
    %----------------------------------------------------------------------
    methods
        function obj = HelperMotionPrediction(varargin)
            % Support name-value pair arguments when constructing object
            setProperties(obj,nargin,varargin{:})
            coder.varsize('referencePathPoints');
            
            % Initialize RefPathPoints.
            referencePathPoints = [0 0; 600, 0];
            obj.RefPathPoints = referencePathPoints;
        end
    end
    
    methods(Access = protected)
        %------------------------------------------------------------------
        function setupImpl(obj)
            % setupImpl function performs the one time calculations and
            % Initializations
            % The setupImpl function is used to initialize values or
            % the object to RefPathFrent and compute the maximum
            % of the timeHorizons (if given a range)
            
            % Construct and assign referencePathFrenet object with a
            % default initial path to RefPathFrenet
            obj.RefPathFrenet = referencePathFrenet(obj.RefPathPoints);           
        end
        
        %------------------------------------------------------------------
        function FutureTrajectories = stepImpl(obj, Params, MapInfo, MIOs)
            % stepImpl executes the main algorithm and generates the MIO
            % Positions and the future trajectories of the MIOs using a
            % constant velocity model.
            %
            % The input MIOs Frenet states are used to estimate the future
            % states in world coordinates. Assuming that these MIOs are
            % moving with a constant velocity the future states are
            % predicted using constant velocity model. Computations are
            % done in Frenet Coordinates for ease of calculations.
            obj.TimeHorizons = Params.TimeHorizon;
            obj.TimeResolution = Params.TimeResolution;
            
            % Check if there is any change in the waypoints and update the
            % RefPathFrenet object
            refPath = MapInfo.GlobalPlanPoints(1:MapInfo.NumGlobalPlanPoints,:);
            if ~isequal(obj.RefPathFrenet.Waypoints,refPath)
                obj.RefPathPoints = MapInfo.GlobalPlanPoints(1:MapInfo.NumGlobalPlanPoints,:);
                obj.RefPathFrenet.Waypoints = obj.RefPathPoints;
            end
            
            % Initialize FutureTrajectory structure to hold the future
            % trajectories of MIOs
            FutureTrajectories = obj.PredictedTrajectoryInitStruct;
            
            % Calculating the number of states needed to be predicted
            maxNumStates = (max(obj.TimeHorizons))/(obj.TimeResolution)+1;
            
            % Extract MIOs information from input
            numMIOs = MIOs.NumMIOs;
            targetIDS = uint8(zeros(obj.NumTargets,1));
            targetIDS(1:numMIOs,1) = MIOs.TargetIds(1, 1:numMIOs);
            numTrajs = 0;
            
            %% Calculate the future motion of MIOs using constant velocity model
            for j = 1:numMIOs
                % Validate the MIO information
                if all(~isnan((MIOs.MIOStates(j,:))))
                    numTrajs = numTrajs + 1;
                    
                    % Get Initial state of the MIO
                    initFrenetState = MIOs.MIOStates(j,:);                                       
                    times = Params.TimeResolution*(0:maxNumStates-1);
                    
                    % predict target trajectory in Frenet frame
                    frenetStates = repmat(initFrenetState,maxNumStates,1);
                    frenetStates(:,1) = frenetStates(:,1) + times(:)*initFrenetState(2); % initFrenetState(2) = ds/dt
                    ds = Params.TimeResolution*initFrenetState(2);
                    dl = ds*initFrenetState(5);
                    for i = 2:maxNumStates
                        frenetStates(i,1) = frenetStates(i-1,1) + ds; % initFrenetState(5) = dl/ds
                        frenetStates(i,4) = frenetStates(i-1,4) + dl; % initFrenetState(5) = dl/ds
                    end
                    
                    % Update the FutureTrajectory structure
                    FutureTrajectories.Trajectories(numTrajs).Trajectory(1:maxNumStates,:)= frenet2global(obj.RefPathFrenet, frenetStates(1:maxNumStates,:));
                    FutureTrajectories.Trajectories(numTrajs).NumPts = uint16(maxNumStates);
                    FutureTrajectories.Trajectories(numTrajs).TargetID = uint8(MIOs.TargetIds(j));
                end
            end
            FutureTrajectories.NumTrajs = uint8(numTrajs);
            for i=1:size(targetIDS,1)
                FutureTrajectories.TargetIDs(i,1) = uint8(targetIDS(i,1));
            end
        end
    end
    
    %----------------------------------------------------------------------
    % Common methods
    %----------------------------------------------------------------------
    methods(Access = protected)
        %------------------------------------------------------------------
        function s = saveObjectImpl(obj)
            % save object
            s = saveObjectImpl@matlab.System(obj);
        end
        
        %------------------------------------------------------------------
        function loadObjectImpl(obj,s,wasLocked)
            % load object
            loadObjectImpl@matlab.System(obj,s,wasLocked);
        end
    end
    
    %----------------------------------------------------------------------
    % Simulink-only methods
    %----------------------------------------------------------------------
    methods(Access = protected)
        %------------------------------------------------------------------
        
        function futureTrajectory = getOutputSizeImpl(~)
            % Return size for each output port
            futureTrajectory = 1;
        end
        %------------------------------------------------------------------
        function futureTrajectory = getOutputDataTypeImpl(~)
            % Return data type for each output port            
            futureTrajectory = "BusPredictedTrajectories";
        end
        %------------------------------------------------------------------
        function futureTrajectory = isOutputComplexImpl(~)
            % Return true for each output port with complex data
            futureTrajectory  = false;
        end
        %------------------------------------------------------------------
        function futureTrajectory = isOutputFixedSizeImpl(~)
            % Return true for each output port with fixed size
            futureTrajectory = true;
        end
    end    
end